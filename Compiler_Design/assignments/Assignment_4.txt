Compiler Design - Assignment 4: Advanced Compiler Components

Problem Statement

1. Implement Symbol Table
Write a Program to implement Symbol Table.

Simple Answer:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 100

struct SymbolTable {
    char symbol[MAX][20];
    char type[MAX][10];
    int size[MAX];
    int val[MAX];
    int count;
};

struct SymbolTable st;

void init() {
    st.count = 0;
}

int search(char *sym) {
    for(int i = 0; i < st.count; i++) {
        if(strcmp(st.symbol[i], sym) == 0) {
            return i;
        }
    }
    return -1;
}

void insert(char *sym, char *t, int s, int v) {
    if(search(sym) == -1) {
        strcpy(st.symbol[st.count], sym);
        strcpy(st.type[st.count], t);
        st.size[st.count] = s;
        st.val[st.count] = v;
        st.count++;
        printf("Symbol inserted successfully.\n");
    } else {
        printf("Symbol already exists.\n");
    }
}

void display() {
    printf("\nSymbol Table:\n");
    printf("Symbol	Type	Size	Value\n");
    for(int i = 0; i < st.count; i++) {
        printf("%s	%s	%d	%d\n", st.symbol[i], st.type[i], st.size[i], st.val[i]);
    }
}

void update(char *sym, int v) {
    int pos = search(sym);
    if(pos != -1) {
        st.val[pos] = v;
        printf("Value updated.\n");
    } else {
        printf("Symbol not found.\n");
    }
}

int main() {
    int choice;
    char symbol[20], type[10];
    int size, val, pos;

    init();

    while(1) {
        printf("\n1. Insert\n2. Display\n3. Search\n4. Update\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch(choice) {
            case 1:
                printf("Enter symbol name: ");
                scanf("%s", symbol);
                printf("Enter type: ");
                scanf("%s", type);
                printf("Enter size: ");
                scanf("%d", &size);
                printf("Enter value: ");
                scanf("%d", &val);
                insert(symbol, type, size, val);
                break;

            case 2:
                display();
                break;

            case 3:
                printf("Enter symbol name to search: ");
                scanf("%s", symbol);
                pos = search(symbol);
                if(pos == -1) {
                    printf("Symbol not found.\n");
                } else {
                    printf("Symbol found at position %d\n", pos);
                }
                break;

            case 4:
                printf("Enter symbol name to update: ");
                scanf("%s", symbol);
                printf("Enter new value: ");
                scanf("%d", &val);
                update(symbol, val);
                break;

            case 5:
                exit(0);

            default:
                printf("Invalid choice.\n");
        }
    }

    return 0;
}


2. BNF Rules to YACC with AST
Write a Program to Convert the BNF rules into YACC form and write code to generate Abstract Syntax Tree

Simple Answer:
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct ASTNode {
    int type; // 0: number, 1: operator
    union {
        int value; // for numbers
        char op;   // for operators
    };
    struct ASTNode* left;
    struct ASTNode* right;
};

struct ASTNode* createNode(int type, int value, char op, struct ASTNode* left, struct ASTNode* right) {
    struct ASTNode* node = (struct ASTNode*)malloc(sizeof(struct ASTNode));
    node->type = type;
    if(type == 0) // Number
        node->value = value;
    else // Operator
        node->op = op;
    node->left = left;
    node->right = right;
    return node;
}

void printAST(struct ASTNode* root, int depth) {
    if(root == NULL) return;

    for(int i = 0; i < depth; i++) printf("  ");

    if(root->type == 0) { // Value
        printf("%d\n", root->value);
    } else { // Operator
        printf("%c\n", root->op);
    }

    printAST(root->left, depth + 1);
    printAST(root->right, depth + 1);
}

int evaluateAST(struct ASTNode* root) {
    if(root == NULL) return 0;
    if(root->type == 0) return root->value; // Leaf node

    int left_val = evaluateAST(root->left);
    int right_val = evaluateAST(root->right);

    switch(root->op) {
        case '+': return left_val + right_val;
        case '-': return left_val - right_val;
        case '*': return left_val * right_val;
        case '/':
            if(right_val != 0) return left_val / right_val;
            else {
                printf("Error: Division by zero\n");
                return 0;
            }
        default: return 0;
    }
}

extern int yylex();
void yyerror(char *s);
%}

%union {
    struct ASTNode* node;
    int value;
}

%token <value> NUMBER
%type <node> expr term factor
%left '+' '-'
%left '*' '/'
%%

program: expr {
    printf("AST generated:\n");
    printAST($1, 0);
    printf("Result: %d\n", evaluateAST($1));
    exit(0);
}
    ;

expr: expr '+' term { $$ = createNode(1, 0, '+', $1, $3); }
    | expr '-' term { $$ = createNode(1, 0, '-', $1, $3); }
    | term { $$ = $1; }
    ;

term: term '*' factor { $$ = createNode(1, 0, '*', $1, $3); }
    | term '/' factor { $$ = createNode(1, 0, '/', $1, $3); }
    | factor { $$ = $1; }
    ;

factor: '(' expr ')' { $$ = $2; }
      | NUMBER { $$ = createNode(0, $1, '\0', NULL, NULL); }
      ;

%%

void yyerror(char *s) {
    fprintf(stderr, "Parse error: %s\n", s);
}

int main() {
    printf("Enter expression: ");
    yyparse();
    return 0;
}


3. Implement Type Checking
Write a C program to implement type checking.

Simple Answer:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_VARS 100

enum Type { INT, FLOAT, CHAR, BOOL };

struct Variable {
    char name[50];
    enum Type type;
};

struct Variable variables[MAX_VARS];
int var_count = 0;

int get_type_index(const char *type_str) {
    if(strcmp(type_str, "int") == 0) return INT;
    if(strcmp(type_str, "float") == 0) return FLOAT;
    if(strcmp(type_str, "char") == 0) return CHAR;
    if(strcmp(type_str, "bool") == 0) return BOOL;
    return -1;
}

int find_variable(const char *name) {
    for(int i = 0; i < var_count; i++) {
        if(strcmp(variables[i].name, name) == 0) {
            return i;
        }
    }
    return -1;
}

void add_variable(const char *name, const char *type_str) {
    if(find_variable(name) == -1) {
        strcpy(variables[var_count].name, name);
        variables[var_count].type = get_type_index(type_str);
        var_count++;
        printf("Variable '%s' of type '%s' added.\n", name, type_str);
    } else {
        printf("Variable '%s' already exists.\n", name);
    }
}

int compatible_types(enum Type src, enum Type dest) {
    // Allow all numeric conversions for simplicity
    if(src == dest) return 1;
    if((src == INT && dest == FLOAT) || (src == FLOAT && dest == INT)) return 1;
    if(src == INT && dest == CHAR) return 1;
    if(src == CHAR && dest == INT) return 1;
    return 0;
}

int perform_type_check(const char *dest_name, const char *src_name) {
    int dest_idx = find_variable(dest_name);
    int src_idx = find_variable(src_name);

    if(dest_idx == -1) {
        printf("Error: Destination variable '%s' not declared.\n", dest_name);
        return 0;
    }

    if(src_idx == -1) {
        printf("Error: Source variable '%s' not declared.\n", src_name);
        return 0;
    }

    if(compatible_types(variables[src_idx].type, variables[dest_idx].type)) {
        printf("Type check passed: %s to %s\n", src_name, dest_name);
        return 1;
    } else {
        printf("Type error: Cannot assign %s to %s\n", src_name, dest_name);
        return 0;
    }
}

int main() {
    int choice;
    char name[50], type[20], dest[50], src[50];

    while(1) {
        printf("\n1. Declare variable\n2. Type check assignment\n3. Display variables\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch(choice) {
            case 1:
                printf("Enter variable name: ");
                scanf("%s", name);
                printf("Enter type (int/float/char/bool): ");
                scanf("%s", type);
                add_variable(name, type);
                break;

            case 2:
                printf("Enter destination variable: ");
                scanf("%s", dest);
                printf("Enter source variable: ");
                scanf("%s", src);
                perform_type_check(dest, src);
                break;

            case 3:
                printf("Declared variables:\n");
                for(int i = 0; i < var_count; i++) {
                    printf("%s : ", variables[i].name);
                    switch(variables[i].type) {
                        case INT: printf("int\n"); break;
                        case FLOAT: printf("float\n"); break;
                        case CHAR: printf("char\n"); break;
                        case BOOL: printf("bool\n"); break;
                    }
                }
                break;

            case 4:
                exit(0);

            default:
                printf("Invalid choice.\n");
        }
    }

    return 0;
}


4. Control Flow and Data Flow Analysis
Write a C program to implement control flow analysis and Data flow Analysis.

Simple Answer:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NODES 100
#define MAX_EDGES 200

struct CFGNode {
    int id;
    char statement[100];
    int next_nodes[MAX_NODES];
    int next_count;
    int visited;
};

struct CFGNode cfg[MAX_NODES];
int node_count = 0;

void init_cfg() {
    for(int i = 0; i < MAX_NODES; i++) {
        cfg[i].id = -1;
        cfg[i].next_count = 0;
        cfg[i].visited = 0;
        for(int j = 0; j < MAX_NODES; j++) {
            cfg[i].next_nodes[j] = -1;
        }
    }
}

void add_node(int id, char* stmt) {
    cfg[node_count].id = id;
    strcpy(cfg[node_count].statement, stmt);
    cfg[node_count].next_count = 0;
    node_count++;
}

void add_edge(int from, int to) {
    cfg[from].next_nodes[cfg[from].next_count] = to;
    cfg[from].next_count++;
}

void print_cfg() {
    printf("Control Flow Graph:\n");
    for(int i = 0; i < node_count; i++) {
        printf("Node %d: %s\n", cfg[i].id, cfg[i].statement);
        printf("  -> ");
        for(int j = 0; j < cfg[i].next_count; j++) {
            printf("Node %d ", cfg[i].next_nodes[j]);
        }
        printf("\n");
    }
}

void dfs_cfg(int start) {
    cfg[start].visited = 1;
    printf("Visiting Node %d: %s\n", cfg[start].id, cfg[start].statement);

    for(int i = 0; i < cfg[start].next_count; i++) {
        int next_node = cfg[start].next_nodes[i];
        if(!cfg[next_node].visited) {
            dfs_cfg(next_node);
        }
    }
}

void reset_visited() {
    for(int i = 0; i < node_count; i++) {
        cfg[i].visited = 0;
    }
}

void simple_data_flow_analysis() {
    printf("\nSimple Data Flow Analysis (Liveness):\n");
    for(int i = 0; i < node_count; i++) {
        printf("Node %d: %s - Live variables: [to be computed based on usage]\n",
               cfg[i].id, cfg[i].statement);
    }
    // This is a simplified version - real implementation would track variable definitions and uses
}

int main() {
    init_cfg();

    // Create a simple CFG example: if-then-else structure
    add_node(0, "Read x, y");
    add_node(1, "if (x > 0)");
    add_node(2, "z = x + y");
    add_node(3, "z = x - y");
    add_node(4, "Print z");

    // Add edges: 0->1, 1->2, 1->3, 2->4, 3->4
    add_edge(0, 1);
    add_edge(1, 2);
    add_edge(1, 3);
    add_edge(2, 4);
    add_edge(3, 4);

    print_cfg();

    printf("\nDFS traversal starting from node 0:\n");
    reset_visited();
    dfs_cfg(0);

    simple_data_flow_analysis();

    return 0;
}