<!DOCTYPE html>
<html lang="en" class="scroll-smooth">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISC Class 11 Recursion Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- 
    Chosen Palette: Calm Neutrals (Slate, Blue, Emerald)
    Application Structure Plan: A single-page, scroll-to-section design with a sticky header navigation. This is chosen for its simplicity and ease of navigation, mirroring a study guide's chapters. Key sections: 1. Introduction (Base/Recursive Case). 2. Core Theory (Interactive Q&A toggles). 3. Recursion vs. Iteration (Comparison Table). 4. Call Stack Visualizer (HTML div-based animation). 5. Programming Problem Explorer (Click-to-load code, explanation, and an interactive "Try it Out" panel). This structure is user-friendly for a student, separating theory from practice and providing interaction for both.
    Visualization & Content Choices:
    - Report Info: Core theory Q&A (What is base case, etc.). Goal: Inform, facilitate self-quizzing. Viz/Method: JS-powered toggles (divs). Interaction: Click on question to reveal answer. Justification: Active recall is better for studying than passive reading. Library: Vanilla JS.
    - Report Info: Recursion vs. Iteration. Goal: Compare. Viz/Method: Styled HTML table. Interaction: None (static comparison). Justification: Table is the clearest way to compare two concepts. Library: HTML/Tailwind.
    - Report Info: Call Stack mechanism. Goal: Organize, show change. Viz/Method: HTML divs styled as a stack. Interaction: Button click animates divs "pushing" and "popping" onto the stack visual with text explanations. Justification: Visually demonstrates the abstract LIFO concept, which is crucial for understanding recursion. NO SVG/Mermaid used. Library: Vanilla JS + HTML/Tailwind.
    - Report Info: Various programming problems (Factorial, Fib, etc.). Goal: Inform, allow practice. Viz/Method: A "Problem Explorer" UI. A grid of buttons (problem names) and a content area that dynamically updates. Interaction: Click button -> JS updates problem statement, code (in a <pre><code> block), explanation, and an interactive "Try it Out" section (input field + run button). The "Run" button executes the recursive logic in JS and displays the result. Justification: This is the core "app." It lets users explore all problems from one view and interactively test the logic. Library: Vanilla JS.
    - Report Info: Charts/Graphs (None in the source report). Goal: N/A. Viz/Method: No charts needed. Interaction: N/A. Justification: The content is conceptual and code-based. Charts (like performance) would be overkill for Class 11. Library: N/A.
    CONFIRMATION: NO SVG graphics used. NO Mermaid JS used.
    -->
    <style>
        :root {
            --bg-main: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-dark: #0f172a;
            --text-main: #1e293b;
            --text-light: #475569;
            --text-dark-bg: #e2e8f0;
            --border-color: #e2e8f0;
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --accent: #10b981;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
        }

        .nav-link {
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-light);
            transition: color 0.2s;
        }

        .nav-link:hover {
            color: var(--primary);
        }

        .btn-primary {
            padding: 0.5rem 1rem;
            background-color: var(--primary);
            color: white;
            font-weight: 500;
            border-radius: 0.5rem;
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            transition: background-color 0.2s;
        }

        .btn-primary:hover {
            background-color: var(--primary-hover);
        }

        .btn-secondary {
            padding: 0.5rem 0.75rem;
            background-color: white;
            color: var(--primary);
            border: 1px solid var(--primary);
            font-weight: 500;
            border-radius: 0.5rem;
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background-color: var(--primary);
            color: white;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
        }

        .btn-selector {
            padding: 0.5rem 0.75rem;
            background-color: #f3f4f6;
            color: var(--text-light);
            font-weight: 500;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .btn-selector:hover {
            background-color: #e5e7eb;
            color: var(--text-main);
        }

        .btn-selector:focus {
            background-color: var(--primary);
            color: white;
            outline: none;
            box-shadow: 0 0 0 2px white, 0 0 0 4px var(--primary);
        }

        .card {
            background-color: var(--bg-secondary);
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .code-block {
            display: block;
            width: 100%;
            padding: 1rem;
            background-color: var(--bg-dark);
            color: var(--text-dark-bg);
            border-radius: 0.375rem;
            overflow-x: auto;
            font-size: 0.875rem;
        }

        .stack-item {
            background-color: var(--accent);
            color: white;
            font-size: 0.875rem;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            text-align: center;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            transition: all 0.3s;
        }

        .question-btn {
            width: 100%;
            text-align: left;
            padding: 1rem 1.25rem;
            background-color: white;
            font-weight: 500;
            color: var(--text-main);
            border-radius: 0.5rem;
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            border: 1px solid var(--border-color);
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .question-btn:hover {
            background-color: #f9fafb;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
        }

        .answer-panel {
            padding: 1.25rem;
            background-color: #f9fafb;
            border: 1px solid var(--border-color);
            border-top: 0;
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        section {
            padding-top: 4rem;
            padding-bottom: 4rem;
        }

        @media (min-width: 768px) {
            section {
                padding-top: 5rem;
                padding-bottom: 5rem;
            }
        }

        h2 {
            font-size: 1.875rem;
            font-weight: 700;
            text-align: center;
            color: var(--text-main);
            margin-bottom: 1rem;
        }

        @media (min-width: 768px) {
            h2 {
                font-size: 2.25rem;
            }
        }

        .section-intro {
            max-width: 48rem;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
            font-size: 1rem;
            color: var(--text-light);
            margin-bottom: 3rem;
        }

        @media (min-width: 768px) {
            .section-intro {
                font-size: 1.125rem;
            }
        }
    </style>
</head>

<body class="antialiased">

    <header class="sticky top-0 z-50 bg-white/95 backdrop-blur-sm shadow-sm border-b border-[var(--border-color)]">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <a href="#" class="text-2xl font-bold text-[var(--primary)]">ISC Recursion Guide</a>
            <div class="hidden md:flex items-center space-x-6">
                <a href="#intro" class="nav-link">Introduction</a>
                <a href="#theory" class="nav-link">Core Theory</a>
                <a href="#comparison" class="nav-link">vs. Iteration</a>
                <a href="#stack" class="nav-link">Call Stack</a>
                <a href="#problems" class="nav-link">Problems</a>
            </div>
            <button id="mobile-menu-btn" class="md:hidden p-2 rounded-md text-[var(--text-light)] hover:bg-gray-100">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16">
                    </path>
                </svg>
            </button>
        </nav>
        <div id="mobile-menu" class="hidden md:hidden px-6 pb-4 border-t border-[var(--border-color)]">
            <a href="#intro" class="block py-2 nav-link mobile-nav-link">Introduction</a>
            <a href="#theory" class="block py-2 nav-link mobile-nav-link">Core Theory</a>
            <a href="#comparison" class="block py-2 nav-link mobile-nav-link">vs. Iteration</a>
            <a href="#stack" class="block py-2 nav-link mobile-nav-link">Call Stack</a>
            <a href="#problems" class="block py-2 nav-link mobile-nav-link">Problems</a>
        </div>
    </header>

    <main class="container mx-auto p-6">

        <section id="intro" class="scroll-mt-20">
            <h2>What is Recursion?</h2>
            <p class="section-intro">
                Recursion is a fundamental programming concept where a function solves a problem by calling itself with
                a smaller or simpler version of the same problem. This section breaks down the two essential parts of
                any recursive solution.
            </p>
            <div class="grid md:grid-cols-2 gap-8">
                <div class="card p-8">
                    <span class="text-5xl">ðŸ›‘</span>
                    <h3 class="text-2xl font-bold mt-4 mb-2">The Base Case</h3>
                    <p class="text-[var(--text-light)]">
                        This is the terminating condition. It's the simplest version of the problem that can be solved
                        directly, without making another recursive call. Without a base case, a recursive function would
                        call itself forever, leading to a "Stack Overflow" error.
                    </p>
                </div>
                <div class="card p-8">
                    <span class="text-5xl">ðŸ”„</span>
                    <h3 class="text-2xl font-bold mt-4 mb-2">The Recursive Case</h3>
                    <p class="text-[var(--text-light)]">
                        This is where the function calls itself, but with a modified argument that moves it closer to
                        the base case. It breaks the problem down into a smaller piece and combines its result with the
                        solution from the recursive call.
                    </p>
                </div>
            </div>
        </section>

        <section id="theory" class="scroll-mt-20">
            <h2>Core Theory Q&A</h2>
            <p class="section-intro">
                These are the most common theory questions you'll encounter. Click on any question to reveal the answer.
                This is a great way to test your understanding of the key concepts.
            </p>
            <div id="qa-container" class="max-w-3xl mx-auto space-y-4">
            </div>
        </section>

        <section id="comparison" class="scroll-mt-20">
            <h2>Recursion vs. Iteration</h2>
            <p class="section-intro">
                Understanding the differences between recursion and iteration (using loops like `for` or `while`) is a
                classic exam topic. Both can solve the same problems, but they have different trade-offs.
            </p>
            <div class="max-w-4xl mx-auto card overflow-hidden">
                <div class="overflow-x-auto">
                    <table class="w-full text-left">
                        <thead class="bg-gray-50 border-b border-[var(--border-color)]">
                            <tr>
                                <th class="px-6 py-4 text-sm font-medium text-[var(--text-main)]">Aspect</th>
                                <th class="px-6 py-4 text-sm font-medium text-[var(--text-main)]">Recursion</th>
                                <th class="px-6 py-4 text-sm font-medium text-[var(--text-main)]">Iteration</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-[var(--border-color)]">
                            <tr>
                                <td class="px-6 py-4 font-medium">Mechanism</td>
                                <td class="px-6 py-4 text-[var(--text-light)]">Function calls itself.</td>
                                <td class="px-6 py-4 text-[var(--text-light)]">A loop (e.g., `for`, `while`) repeats a
                                    block of code.</td>
                            </tr>
                            <tr>
                                <td class="px-6 py-4 font-medium">Termination</td>
                                <td class="px-6 py-4 text-[var(--text-light)]">Ends when the base case is reached.</td>
                                <td class="px-6 py-4 text-[var(--text-light)]">Ends when the loop condition becomes
                                    false.</td>
                            </tr>
                            <tr>
                                <td class="px-6 py-4 font-medium">Memory Usage</td>
                                <td class="px-6 py-4 text-[var(--text-light)]">Uses the call stack. Can be
                                    memory-intensive (risk of Stack Overflow).</td>
                                <td class="px-6 py-4 text-[var(--text-light)]">Uses constant memory (for loop
                                    variables). More memory-efficient.</td>
                            </tr>
                            <tr>
                                <td class="px-6 py-4 font-medium">Code Length</td>
                                <td class="px-6 py-4 text-[var(--text-light)]">Often shorter and more elegant for
                                    problems that are naturally recursive (e.g., tree traversal).</td>
                                <td class="px-6 py-4 text-[var(--text-light)]">Often longer and more complex, requiring
                                    manual state management.</td>
                            </tr>
                            <tr>
                                <td class="px-6 py-4 font-medium">Performance</td>
                                <td class="px-6 py-4 text-[var(--text-light)]">Generally slower due to the overhead of
                                    function calls.</td>
                                <td class="px-6 py-4 text-[var(--text-light)]">Generally faster as there is no function
                                    call overhead.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <section id="stack" class="scroll-mt-20">
            <h2>How it Works: The Call Stack</h2>
            <p class="section-intro">
                Recursion relies on the "call stack" to keep track of all the function calls. When a function is called,
                it's "pushed" onto the stack. When it returns, it's "popped" off. Let's visualize this with
                `factorial(3)`.
            </p>
            <div class="card max-w-5xl mx-auto p-8">
                <div class="flex justify-center mb-8">
                    <button id="run-stack-anim" class="btn-primary text-lg px-6 py-3">Run factorial(3)
                        Animation</button>
                </div>
                <div class="grid md:grid-cols-2 gap-8 items-start">
                    <div class="bg-gray-100 p-6 rounded-lg h-96">
                        <h4 class="font-bold text-center mb-4">Call Stack</h4>
                        <div id="stack-visual"
                            class="h-80 w-4/5 mx-auto bg-white border-2 border-[var(--border-color)] rounded-lg flex flex-col-reverse justify-start p-2 space-y-2 space-y-reverse overflow-hidden">
                        </div>
                    </div>
                    <div class="h-96">
                        <h4 class="font-bold mb-4">Explanation:</h4>
                        <p id="stack-explanation"
                            class="text-[var(--text-light)] h-full p-4 bg-gray-50 rounded-lg border border-[var(--border-color)] overflow-y-auto">
                            Click the button to start the animation and see how the call stack works step-by-step.
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <section id="problems" class="scroll-mt-20">
            <h2>Programming Problem Explorer</h2>
            <p class="section-intro">
                This is the best way to prepare for the programming part of the exam. Select a problem to see its
                solution, a detailed explanation of the logic, and an interactive "Try It Out" panel to test your
                understanding.
            </p>
            <div class="card max-w-7xl mx-auto">
                <div class="grid md:grid-cols-12 gap-0">
                    <div class="md:col-span-3 p-6 border-r border-[var(--border-color)] bg-gray-50/50">
                        <h4 class="font-bold mb-4">Select a Problem:</h4>
                        <div id="problem-selector" class="flex flex-row flex-wrap md:flex-col gap-2">
                        </div>
                    </div>
                    <div class="md:col-span-9 p-8">
                        <div id="problem-display">
                            <h3 id="problem-title" class="text-2xl font-bold mb-3 text-[var(--primary)]"></h3>
                            <p id="problem-statement" class="text-[var(--text-light)] mb-4"></p>

                            <h4 class="font-medium text-lg mt-6 mb-2">Java Solution:</h4>
                            <pre><code id="problem-code" class="code-block"></code></pre>

                            <h4 class="font-medium text-lg mt-6 mb-2">Logic Explanation:</h4>
                            <p id="problem-explanation"
                                class="text-[var(--text-light)] p-4 bg-gray-50 rounded-lg border border-[var(--border-color)]">
                            </p>

                            <h4 class="font-medium text-lg mt-6 mb-2">Try It Out!</h4>
                            <div id="problem-runner"
                                class="p-6 bg-white rounded-lg border border-[var(--border-color)] shadow-inner">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <footer class="text-center py-12 border-t border-[var(--border-color)] mt-16">
        <p class="text-[var(--text-light)]">An interactive guide for ISC Class 11 Computer Science.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const theoryQuestions = [
                {
                    q: "What is a base case and why is it essential?",
                    a: "The base case is the condition that stops the recursion. It's the simplest form of the problem that can be solved directly. It is essential because, without it, the function would call itself indefinitely, leading to a stack overflow error."
                },
                {
                    q: "What are the advantages of recursion?",
                    a: "Recursion can lead to shorter, more elegant, and easier-to-read code for problems that are naturally recursive (like tree traversals or the Fibonacci sequence). It breaks down complex problems into simpler, manageable sub-problems."
                },
                {
                    q: "What are the disadvantages of recursion?",
                    a: "Recursion can be less efficient than iteration due to the overhead of function calls and return. It consumes more memory because each function call is added to the call stack. If the recursion is too deep, it can cause a stack overflow."
                },
                {
                    q: "What are the types of recursion?",
                    a: "<strong>Direct Recursion:</strong> A function calls itself.<br><strong>Indirect Recursion:</strong> A function (A) calls another function (B), which in turn calls the first function (A).<br><strong>Tail Recursion:</strong> The recursive call is the very last operation in the function. This can be optimized by compilers to be as efficient as iteration.<br><strong>Non-Tail Recursion:</strong> The recursive call is not the last operation (e.g., `n * factorial(n-1)` requires a multiplication after the call)."
                }
            ];

            const qaContainer = document.getElementById('qa-container');
            theoryQuestions.forEach((item, index) => {
                const qaId = `qa-${index}`;
                const qaBlock = document.createElement('div');
                qaBlock.innerHTML = `
                    <button class="question-btn" data-answer-id="${qaId}">
                        <span>${item.q}</span>
                        <svg class="w-5 h-5 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="${qaId}" class="answer-panel hidden">
                        <p class="text-[var(--text-light)]">${item.a}</p>
                    </div>
                `;
                qaContainer.appendChild(qaBlock);
            });

            qaContainer.addEventListener('click', (e) => {
                const btn = e.target.closest('.question-btn');
                if (btn) {
                    const answerId = btn.dataset.answerId;
                    const answerPanel = document.getElementById(answerId);
                    const icon = btn.querySelector('svg');

                    answerPanel.classList.toggle('hidden');
                    icon.classList.toggle('rotate-180');
                }
            });

            const problems = {
                factorial: {
                    title: "Factorial of a Number",
                    statement: "Write a recursive function to find the factorial of a non-negative integer 'n' (n!).",
                    code: `public int factorial(int n) {
    // Base Case
    if (n == 0 || n == 1) {
        return 1;
    }
    // Recursive Case
    return n * factorial(n - 1);
}`,
                    explanation: "The base case is when n is 0 or 1, which returns 1. The recursive step multiplies n by the factorial of (n-1). Each call reduces n, moving closer to the base case.",
                    runner: {
                        inputs: [{ id: 'n', label: 'Enter n:', type: 'number', default: 5 }],
                        logic: (inputs) => {
                            const n = parseInt(inputs.n, 10);
                            if (isNaN(n) || n < 0) return "Error: n must be a non-negative integer.";
                            function fact(num) {
                                if (num === 0 || num === 1) return 1;
                                if (num > 20) return "Result too large to display.";
                                return num * fact(num - 1);
                            }
                            return `factorial(${n}) = ${fact(n)}`;
                        }
                    }
                },
                fibonacci: {
                    title: "N-th Fibonacci Number",
                    statement: "Write a recursive function to find the n-th term of the Fibonacci sequence (0, 1, 1, 2, 3, 5, 8...).",
                    code: `public int fibonacci(int n) {
    // Base Cases
    if (n <= 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    // Recursive Case
    return fibonacci(n - 1) + fibonacci(n - 2);
}`,
                    explanation: "There are two base cases: n=0 (returns 0) and n=1 (returns 1). The recursive step calculates the n-th term by summing the (n-1)th and (n-2)th terms.",
                    runner: {
                        inputs: [{ id: 'n', label: 'Enter n:', type: 'number', default: 6 }],
                        logic: (inputs) => {
                            const n = parseInt(inputs.n, 10);
                            if (isNaN(n) || n < 0) return "Error: n must be a non-negative integer.";
                            if (n > 30) return "Error: n > 30 is too slow for this simple recursive version.";
                            function fib(num) {
                                if (num <= 0) return 0;
                                if (num === 1) return 1;
                                return fib(num - 1) + fib(num - 2);
                            }
                            return `fibonacci(${n}) = ${fib(n)}`;
                        }
                    }
                },
                gcd: {
                    title: "Greatest Common Divisor (GCD)",
                    statement: "Write a recursive function to find the GCD (or HCF) of two numbers using the Euclidean algorithm.",
                    code: `public int gcd(int a, int b) {
    // Base Case
    if (b == 0) {
        return a;
    }
    // Recursive Case
    return gcd(b, a % b);
}`,
                    explanation: "The base case is when the second number 'b' becomes 0. At this point, the first number 'a' is the GCD. The recursive step calls gcd with 'b' as the new 'a' and the remainder of 'a / b' as the new 'b'.",
                    runner: {
                        inputs: [
                            { id: 'a', label: 'Enter a:', type: 'number', default: 54 },
                            { id: 'b', label: 'Enter b:', type: 'number', default: 24 }
                        ],
                        logic: (inputs) => {
                            const a = parseInt(inputs.a, 10);
                            const b = parseInt(inputs.b, 10);
                            if (isNaN(a) || isNaN(b)) return "Error: Both inputs must be integers.";
                            function findGcd(x, y) {
                                if (y === 0) return x;
                                return findGcd(y, x % y);
                            }
                            return `gcd(${a}, ${b}) = ${findGcd(Math.abs(a), Math.abs(b))}`;
                        }
                    }
                },
                palindrome: {
                    title: "String Palindrome Check",
                    statement: "Write a recursive function that returns true if a string is a palindrome (reads the same forwards and backwards) and false otherwise.",
                    code: `public boolean isPalindrome(String s) {
    s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
    return check(s, 0, s.length() - 1);
}

private boolean check(String s, int start, int end) {
    // Base Case 1
    if (start >= end) {
        return true;
    }
    // Base Case 2
    if (s.charAt(start) != s.charAt(end)) {
        return false;
    }
    // Recursive Case
    return check(s, start + 1, end - 1);
}`,
                    explanation: "First, the string is cleaned. The helper function 'check' has two base cases: if the start/end pointers cross, it's a palindrome (true). If the characters at start and end don't match, it's not (false). The recursive step calls 'check' with the pointers moved one step inwards.",
                    runner: {
                        inputs: [{ id: 's', label: 'Enter string:', type: 'text', default: 'A man, a plan, a canal: Panama' }],
                        logic: (inputs) => {
                            let s = inputs.s || "";
                            s = s.replaceAll(/[^a-zA-Z0-9]/g, "").toLowerCase();
                            function check(str, start, end) {
                                if (start >= end) return true;
                                if (str.charAt(start) !== str.charAt(end)) return false;
                                return check(str, start + 1, end - 1);
                            }
                            const result = check(s, 0, s.length - 1);
                            return `Is "${inputs.s}" a palindrome? ${result}`;
                        }
                    }
                },
                sumOfDigits: {
                    title: "Sum of Digits",
                    statement: "Write a recursive function to find the sum of the digits of a number.",
                    code: `public int sumOfDigits(int n) {
    n = Math.abs(n);
    // Base Case
    if (n == 0) {
        return 0;
    }
    // Recursive Case
    return (n % 10) + sumOfDigits(n / 10);
}`,
                    explanation: "The base case is when the number 'n' becomes 0, at which point the sum is 0. The recursive step adds the last digit (n % 10) to the sum of the remaining digits (n / 10).",
                    runner: {
                        inputs: [{ id: 'n', label: 'Enter number:', type: 'number', default: 12345 }],
                        logic: (inputs) => {
                            const n = parseInt(inputs.n, 10);
                            if (isNaN(n)) return "Error: Input must be an integer.";
                            function sum(num) {
                                num = Math.abs(num);
                                if (num === 0) return 0;
                                return (num % 10) + sum(Math.floor(num / 10));
                            }
                            return `Sum of digits for ${n} = ${sum(n)}`;
                        }
                    }
                }
            };

            const problemSelector = document.getElementById('problem-selector');
            const titleEl = document.getElementById('problem-title');
            const statementEl = document.getElementById('problem-statement');
            const codeEl = document.getElementById('problem-code');
            const explanationEl = document.getElementById('problem-explanation');
            const runnerEl = document.getElementById('problem-runner');
            let activeBtn = null;

            function loadProblem(key) {
                const data = problems[key];
                if (!data) return;

                titleEl.textContent = data.title;
                statementEl.textContent = data.statement;
                codeEl.textContent = data.code;
                explanationEl.textContent = data.explanation;

                runnerEl.innerHTML = '';
                const inputs = {};

                data.runner.inputs.forEach(input => {
                    const label = document.createElement('label');
                    label.className = 'block text-sm font-medium text-[var(--text-light)] mb-1';
                    label.setAttribute('for', input.id);
                    label.textContent = input.label;

                    const inputEl = document.createElement('input');
                    inputEl.className = 'block w-full px-3 py-2 border border-[var(--border-color)] rounded-md shadow-sm focus:outline-none focus:ring-[var(--primary)] focus:border-[var(--primary)] sm:text-sm';
                    inputEl.type = input.type;
                    inputEl.id = input.id;
                    inputEl.value = input.default;

                    runnerEl.appendChild(label);
                    runnerEl.appendChild(inputEl);
                    inputs[input.id] = inputEl;
                });

                const runBtn = document.createElement('button');
                runBtn.className = 'btn-secondary mt-4';
                runBtn.textContent = 'Run';

                const resultEl = document.createElement('div');
                resultEl.className = 'mt-4 p-4 bg-gray-100 rounded-md text-[var(--text-main)] font-medium';
                resultEl.style.display = 'none';

                runBtn.addEventListener('click', () => {
                    const inputValues = {};
                    for (const id in inputs) {
                        inputValues[id] = inputs[id].value;
                    }
                    const result = data.runner.logic(inputValues);
                    resultEl.textContent = result;
                    resultEl.style.display = 'block';
                });

                runnerEl.appendChild(runBtn);
                runnerEl.appendChild(resultEl);
            }

            Object.keys(problems).forEach((key, index) => {
                const btn = document.createElement('button');
                btn.className = 'btn-selector w-full text-left';
                btn.textContent = problems[key].title;
                btn.dataset.problemKey = key;
                btn.addEventListener('click', () => {
                    loadProblem(key);
                    if (activeBtn) {
                        activeBtn.classList.remove('bg-[var(--primary)]', 'text-white');
                    }
                    btn.classList.add('bg-[var(--primary)]', 'text-white');
                    activeBtn = btn;
                });
                problemSelector.appendChild(btn);

                if (index === 0) {
                    btn.click();
                }
            });

            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            const mobileMenu = document.getElementById('mobile-menu');
            mobileMenuBtn.addEventListener('click', () => {
                mobileMenu.classList.toggle('hidden');
            });

            document.querySelectorAll('.mobile-nav-link').forEach(link => {
                link.addEventListener('click', () => {
                    mobileMenu.classList.add('hidden');
                });
            });

            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    document.querySelector(this.getAttribute('href')).scrollIntoView({
                        behavior: 'smooth'
                    });
                });
            });

            const stackBtn = document.getElementById('run-stack-anim');
            const stackVisual = document.getElementById('stack-visual');
            const stackExplanation = document.getElementById('stack-explanation');

            stackBtn.addEventListener('click', () => {
                stackBtn.disabled = true;
                stackVisual.innerHTML = '';
                stackExplanation.textContent = 'Animation started...';

                const steps = [
                    { delay: 500, visual: 'factorial(3)', text: 'Call factorial(3). 3 is not 0 or 1. Must call factorial(2).' },
                    { delay: 1000, visual: 'factorial(2)', text: 'Call factorial(2). 2 is not 0 or 1. Must call factorial(1).' },
                    { delay: 1000, visual: 'factorial(1)', text: 'Call factorial(1). Base case reached! Return 1.' },
                    { delay: 1500, visual: 'pop', text: 'factorial(1) returns 1. factorial(2) can now compute: 2 * 1 = 2. Return 2.' },
                    { delay: 1500, visual: 'pop', text: 'factorial(2) returns 2. factorial(3) can now compute: 3 * 2 = 6. Return 6.' },
                    { delay: 1500, visual: 'pop', text: 'factorial(3) returns 6. Final result is 6. Stack is empty.' },
                    { delay: 1000, visual: 'clear', text: 'Click the button to run the animation again.' }
                ];

                let chain = Promise.resolve();

                steps.forEach(step => {
                    chain = chain.then(() => new Promise(resolve => {
                        setTimeout(() => {
                            if (step.visual === 'pop') {
                                stackVisual.removeChild(stackVisual.lastChild);
                            } else if (step.visual === 'clear') {
                                stackVisual.innerHTML = '';
                                stackBtn.disabled = false;
                            } else {
                                const item = document.createElement('div');
                                item.className = 'stack-item';
                                item.textContent = step.visual;
                                stackVisual.appendChild(item);
                            }
                            stackExplanation.textContent = step.text;
                            resolve();
                        }, step.delay);
                    }));
                });
            });

        });
    </script>
</body>

</html>